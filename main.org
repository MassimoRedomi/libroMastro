#+title: Libro Mastro
#+author: José Santos L.
* Headers
** Basic libraries
   sono librerie che non credo di aver bisogno di spiegare cosa fanno.
   #+begin_src c :tangle yes
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>/*aggiunge i boolean var*/
#include <math.h>

#define clear() printf("\033[H\033[J") 

   #+end_src
** specific libraries
   #+begin_src c :tangle yes
#include <unistd.h> /*Header file per sleep()*/
#include <pthread.h> /*per fare i thread*/

   #+end_src
* structures
  Le strutture sono gruppi di variabili che rapressentano un
  oggetto della vita reale.
** ReadStruct
   questa struttura solo serve per avere un archivio di dati ordinati
   dei dati letti del file di configurazione. questi dati sono:
|---------------------------------------+------------------------------------------------------------------------------------------------------------------|
| variable                              | description                                                                                                      |
|---------------------------------------+------------------------------------------------------------------------------------------------------------------|
| SO_USERS_NUM                          | numero di processi utente                                                                                        |
| SO_NODES_NUM                          | numero di processi nodo                                                                                          |
| SO_BUDGET_INIT                        | budget iniziale di ciascun processo utente                                                                       |
| SO_REWARD                             | la percentuale di reward pagata da ogni utente per il processamento di una transazione                           |
| SO_MIN_TRANS_GEN_NSEC                 | minimo valore del tempo che trascorre fra la generazione di una transazione e la seguente da parte di un utente  |
| SO_MAX_TRANS_GEN_NSEC                 | massimo valore del tempo che trascorre fra la generazione di una transazione e la seguente da parte di un utente |
| SO_RETRY                              | numero massimo di fallimenti consecutivi nella generazione di transazioni dopo cui un processo utente termina    |
| SO_TP_SIZE                            | numero massimo di transazioni nella transaction pool dei processi nodo                                           |
| SO_MIN_TRANS_PROC_NSEC,               | minimo valore del tempo simulato(nanosecondi) di processamento di un blocco da parte di un nodo                  |
| SO_MAX_TRANS_PROC_NSEC                | massimo valore del tempo simulato(nanosecondi) di processamento di un blocco da parte di un nodo                 |
| SO_SIM_SESC                           | durata della simulazione                                                                                         |
| SO_NUM_FRIENDS (solo versione max 30) | numero di nodi amici dei processi nodo (solo per la versione full)                                               |
| SO_HOPS (solo versione max 30)        | numero massimo di inoltri di una transazione verso nodi amici prima che il master creai un nuovo nodo            |
|---------------------------------------+------------------------------------------------------------------------------------------------------------------|
#+begin_src c :tangle yes

struct readStruct{
   int SO_USERS_NUM;/*numero di processi utente*/
   int SO_NODES_NUM;/*numero di processi nodo*/
   int SO_BUDGET_INIT;/*budget iniziale di ciascun processo utente*/
   int SO_REWARD;/*la percentuale di reward pagata da ogni utente per il processamento di una transazione*/
   int SO_MIN_TRANS_GEN_NSEC;/*minimo valore del tempo che trascorre fra la generazione di una transazione e la seguente da parte di un utente*/
   int SO_MAX_TRANS_GEN_NSEC;/*massimo valore del tempo che trascorre fra la generazione di una transazione e la seguente da parte di un utente*/
   int SO_RETRY;/*numero massimo di fallimenti consecutivi nella generazione di transazioni dopo cui un processo utente termina*/
   int SO_TP_SIZE;/*numero massimo di transazioni nella transaction pool dei processi nodo*/
   int SO_MIN_TRANS_PROC_NSEC;/*minimo valore del tempo simulato(nanosecondi) di processamento di un blocco da parte di un nodo*/
   int SO_MAX_TRANS_PROC_NSEC;/*massimo valore del tempo simulato(nanosecondi) di processamento di un blocco da parte di un nodo*/
   int SO_SIM_SESC;/*durata della simulazione*/
   int SO_NUM_FRIENDS;/*solo per la versione full. numero di nodi amici dei processi nodo (solo per la versione full)*/
   int SO_HOPS;/*solo per la versione full. numero massimo di inoltri di una transazione verso nodi amici prima che il master creai un nuovo nodo*/ 
}configurazione;

#+end_src
   Questa struttura è gia dichiarata con la variabile _configurazione_ 
   perche solo c'è una lettura delle variabili di configurazione.

** utente
   #+begin_src c :tangle yes
struct Utente{
   int id;
   float budget;
};

   #+end_src
** Transazione
   Una transazione è caratterizzata dalle seguenti informazioni:
   • timestamp della transazione con risoluzione dei nanosecondi (si 
     veda funzione clock_gettime(...))
   • sender (implicito, in quanto è l’utente che ha generato la 
     transazione)
   • receiver, utente destinatario della somma
   • quantità di denaro inviata.
   • reward, denaro pagato dal sender al nodo che processa la 
     transazione.

   La transazione è inviata dal processo utente che la genera ad uno 
   dei processi nodo, scelto a caso.
   #+begin_src c :tangle yes
struct Transazione{
   struct Utente sender;
   struct Utente receiver;
   float quantita;
   float reward;
};

   #+end_src
** Node
   #+begin_src c :tangle yes
struct Nodo{
   int id;
   /*unsigned Transazione block[];*/
};
   #+end_src

* main
  #+begin_src c :tangle yes
int main(int argc,char *argv[]){
   if(argc<2){
      printf("si aspettava un file con la configurazione.\n");
      exit(EXIT_FAILURE);
   }else if(argc>2){
      printf("troppi argomenti.\n");
      exit(EXIT_FAILURE);
   }else{
      printf("tutto a posto\n");
   }
   return 0;
}
  #+end_src
