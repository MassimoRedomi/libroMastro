#+title: Libro Mastro
#+author: José Santos L.
* Compilazione
  La compilazione è compresa in un MAKEFILE per passare tutti i 
  parametri:
#+begin_src makefile :tangle Makefile
all:
	gcc -std=c89 -pthread -pedantic -D_GNU_SOURCE -DSO_BLOCK_SIZE=10 -DSO_REGISTRY_SIZE=1000 main.c -lm -o main

#+end_src
** std=c89  
   set the language standard C89.
** pthread
   Setting the binary for thread processing.
** pedantic
** _GNU_SOURCE
   enables GNU extensions to the C and OS standards supported by the 
   GNU C library.
** SO_BLOCK_SIZE
   The size of the block in the simulation.
** SO_REGISTRY_SIZE
   The max size of the libro mastro.
** -lm
   Compiles against the shared library.

* Headers
** Basic libraries
   sono librerie che non credo di aver bisogno di spiegare cosa fanno.
   #+begin_src c :tangle yes
#include <stdio.h>  /*standard input-output header*/
#include <stdlib.h> /*Libreria Standard*/  
#include <time.h>   /*Acquisizione e manipolazione tempo*/
#include <stdbool.h>/*aggiunge i boolean var*/

   #+end_src

** specific libraries
   #+begin_src c :tangle yes
#include <unistd.h>      /*Header per sleep()*/
#include <pthread.h>     /*Per fare i thread*/
#include <semaphore.h>   /*Aggiungi i semafori*/

   #+end_src
** importa le funzioni di utente 

   #+begin_src c :tangle yes

#include "User.c"

   #+end_src
** macro
   Un macro è un frammento di codice a cui viene assegnato un nome.
   #+begin_src c :tangle yes
#define clear() printf("\033[H\033[J") /*clear the screen*/

   #+end_src

* Controllo del LIBRO_MASTRO
  Creazione del libroMastro e tutte le variabili:
  -_libroluck_:   Semaforo per accedere alla scrittura del libroMastro.
  -_libroCounter_:Contatore che indica la quantità di blocchi scritti nel libroMastro.
  #+begin_src c :tangle yes
Transazione libroMastro[SO_REGISTRY_SIZE * SO_BLOCK_SIZE];/*libro mastro dove si scrivono tutte le transazioni.*/
int libroCounter=0;/*Counter controlla la quantitta di blocchi*/
sem_t libroluck;/*luchetto per accedere solo un nodo alla volta*/

   #+end_src
* funzioni in paralelo
  questo spazio è riservato per le funzioni del multithread
  
** memoria condivisa (work in progress)
   i semafori vengono usati per gestire il flusso del programma.
   e sopratutto non accedono diversi processi allo stesso tempo
   allo stesso dato. Uguale a un semaforo normale ci sono 3 stati:
*** 0 avanti
    il processo puo accedere diretamente al dato.
*** <0 aspetta
    il processo deve ancora aspettare per accedere a questo dato
    o direttamente cercare un'alternativa a questo.
*** external resources 
**** general semaphore example https://www.delftstack.com/howto/c/semaphore-example-in-c/
**** trywait https://stackoverflow.com/questions/27294954/how-to-use-sem-trywait
*** lista de semafori e altre dati condivise tra i diversi thread:
    #+begin_src c :tangle yes

/*variabili condivise tra diversi thread.*/
int *retrylist;      /*numero di tentativi di ogni utente*/
int *budgetlist;     /*un registro del budget di ogni utente*/
int *rewardlist;     /*un registro publico del reward totale di ogni nodo.*/
sem_t *semafori;     /*semafori per accedere/bloccare un nodo*/
Transazione *mailbox;/*struttura per condividere */
time_t startSimulation;

    #+end_src
** [[User.org][utente]]
** [[Node.org][Node]]

* Lettura configurazione
** dichiaro variabile configurazione
#+begin_src c :tangle yes
Configurazione configurazione;
#+end_src
** legge file
#+begin_src c :tangle yes
/*Un picollo metodo che fa un fgets(con gli stessi parametri e lo 
ritorna come un valore intero*/
int readAndInt(char *str, int n, FILE *stream){
   fgets(str,n,stream);
   return atoi(str);
}
/*funzione che cerca la maniera di leggere il config file.
/*metodo basato in codice di stackoverflow per leggere file come
una unica struttura.*/
void readconf(char fileName[]){
   /*secondo lo std c89 tutte le variabile devono 
   essere dichiarate prima del primo codice */
   FILE *file= fopen(fileName, "r");

   if(!file){
      printf("non si trova il config file.\n");
      exit(EXIT_FAILURE);
   }else{
      char line[20];/*str per prendere le righe*/

      /*inserisco le variabili riga a riga alla struttura.*/
      configurazione.SO_USERS_NUM = readAndInt(line,20,file);
      printf("SO_USERS_NUM: %d\n",configurazione.SO_USERS_NUM);
      configurazione.SO_NODES_NUM = readAndInt(line,20,file);
      printf("SO_NODES_NUM: %d\n",configurazione.SO_NODES_NUM);
      configurazione.SO_BUDGET_INIT = readAndInt(line,20,file);
      printf("SO_BUDGET_INIT: %d\n",configurazione.SO_BUDGET_INIT);
      configurazione.SO_REWARD = readAndInt(line,20,file);
      printf("SO_REWARD: %d\n",configurazione.SO_REWARD);
      configurazione.SO_MIN_TRANS_GEN_NSEC = readAndInt(line,20,file);
      printf("SO_MIN_TRANS_GEN_NSEC: %d\n",configurazione.SO_MIN_TRANS_GEN_NSEC);
      configurazione.SO_MAX_TRANS_GEN_NSEC = readAndInt(line,20,file);
      printf("SO_MAX_TRANS_GEN_NSEC: %d\n",configurazione.SO_MAX_TRANS_GEN_NSEC);
      configurazione.SO_RETRY = readAndInt(line,20,file);
      printf("SO_RETRY: %d\n",configurazione.SO_RETRY);
      configurazione.SO_TP_SIZE = readAndInt(line,20,file);
      printf("SO_TP_SIZE: %d\n",configurazione.SO_TP_SIZE);
      configurazione.SO_MIN_TRANS_PROC_NSEC = readAndInt(line,20,file);
      printf("SO_MIN_TRANS_PROC_NSEC: %d\n",configurazione.SO_MIN_TRANS_PROC_NSEC);
      configurazione.SO_MAX_TRANS_PROC_NSEC = readAndInt(line,20,file);
      printf("SO_MAX_TRANS_PROC_NSEC: %d\n",configurazione.SO_MAX_TRANS_PROC_NSEC);
      configurazione.SO_SIM_SEC = readAndInt(line,20,file);
      printf("SO_SIM_SEC: %d\n",configurazione.SO_SIM_SEC);
      configurazione.SO_FRIENDS_NUM = readAndInt(line,20,file);
      printf("SO_FRIENDS_NUM: %d\n",configurazione.SO_FRIENDS_NUM);
      configurazione.SO_HOPS = readAndInt(line,20,file);
      printf("SO_HOPS: %d\n",configurazione.SO_HOPS);
   }
   fclose(file);/*chiusura del file.*/
}

#+end_src
** Scrittura manuale
Forse per la parte di prove. possiamo cambiare la intro delle variabili.
probabilmente cancelliamo questo alla fine del progetto.
l'idea e' poter inserire le variabili a mano
#+begin_src c :tangle yes
/*scritura manuale dei valori del sistema.*/
void writeConf(){
   printf("inserendo il parametro 'mano' o 'manual' si attiva il inserimento manuale dei valori\n\n");
   printf("SO_USERS_NUM: ");
   scanf("%d",&configurazione.SO_USERS_NUM);
   printf("SO_NODES_NUM: ");
   scanf("%d",&configurazione.SO_NODES_NUM);
   printf("SO_BUDGET_INIT: ");
   scanf("%d",&configurazione.SO_BUDGET_INIT);
   printf("SO_REWARD: ");
   scanf("%d",&configurazione.SO_REWARD);
   printf("SO_MIN_TRANS_GEN_NSEC: ");
   scanf("%d",&configurazione.SO_MIN_TRANS_GEN_NSEC);
   printf("SO_MAX_TRANS_GEN_NSEC: ");
   scanf("%d",&configurazione.SO_MAX_TRANS_GEN_NSEC);
   printf("SO_RETRY: ");
   scanf("%d",&configurazione.SO_RETRY);
   printf("SO_TP_SIZE: ");
   scanf("%d",&configurazione.SO_TP_SIZE);
   printf("SO_MIN_TRANS_PROC_NSEC: ");
   scanf("%d",&configurazione.SO_MIN_TRANS_PROC_NSEC);
   printf("SO_MAX_TRANS_PROC_NSEC: ");
   scanf("%d",&configurazione.SO_MAX_TRANS_PROC_NSEC);
   printf("SO_SIM_SEC: ");
   scanf("%d",&configurazione.SO_SIM_SEC);
   printf("SO_FRIENDS_NUM: ");
   scanf("%d",&configurazione.SO_FRIENDS_NUM);
   printf("SO_HOPS: ");
   scanf("%d",&configurazione.SO_HOPS);
   clear();

}
#+end_src
* main
** show users
   #+begin_src c :tangle yes
void showUsers(){
         int i;
	 int counterAttivi=0;
	 bool test;
	 printf("Utenti:\n");
	 /*mostra il budget di ogni utente*/
	 for(i=0; i<configurazione.SO_USERS_NUM; i++){
	    test = retrylist[i]<configurazione.SO_RETRY;
	    if(test)
	       counterAttivi++;
	    printf("%d) %d %s\t",i,budgetlist[i],test ? "true":"false");
	    if(i%9==0)
	       printf("\n");
	 }
	 printf("\nattivi: %d\n",counterAttivi);

}
   #+end_src
** Show nodes
   #+begin_src c :tangle yes
void showNodes(){
         int i;
	 int counterAttivi;
	 printf("\nnodi: \n");
	 for(i=0; i<configurazione.SO_NODES_NUM; i++){
	    sem_getvalue(&semafori[i],&counterAttivi);
	    printf("%d) %d %d\t",i,rewardlist[i],counterAttivi);
	 }
}

   #+end_src

** main function
  #+begin_src c :tangle yes
int main(int argc,char *argv[]){
   int i;
   float now;
   bool test;
   pthread_t tid;
   int counterAttivi;
   if(argc<2){
      printf("si aspettava un file con la configurazione o il commando 'manual'.\n");
      exit(EXIT_FAILURE);
   }else if(argc>2){
      printf("troppi argomenti.\n");
      exit(EXIT_FAILURE);
   }else{
      /*in caso di voler inserire i valori a mano*/
      if( strcmp(argv[1],"mano")==0 || strcmp(argv[1],"manual")==0 ){
         writeConf();
      }else{
         readconf(argv[1]);/*lettura del file*/
      }
      
      /*now that we have all the variables we can start the process
      master*/
      
      startSimulation = time(0);/* el tiempo de ahora*/
      sem_init(&libroluck,0,0);/*inizia il semaforo del libromastro*/

      /*libroMastro=malloc(configurazione.SO_BLOCK_SIZE * configurazione.SO_REGISTRY_SIZE * (4 * sizeof(int)) * sizeof(time_t));*/
      /*generatore dei nodi*/
      rewardlist=malloc(configurazione.SO_NODES_NUM * sizeof(int));
      semafori=malloc(configurazione.SO_NODES_NUM * sizeof(sem_t));
      mailbox=malloc(configurazione.SO_NODES_NUM * (4 * sizeof(int)) * sizeof(time_t));
      for(i=0;i<configurazione.SO_NODES_NUM;i++){
         pthread_create(&tid,NULL,nodo,&i);
	 /*usleep(100);*/
      }
      /*generatore dei utenti*/
      retrylist =malloc(configurazione.SO_USERS_NUM * sizeof(int));
      budgetlist=malloc(configurazione.SO_USERS_NUM * sizeof(int));
      for(i=0;i<configurazione.SO_USERS_NUM;i++){
         pthread_create(&tid,NULL,utente,&i);
	 /*usleep(100);*/
      }
      
      /*now start the master process*/
      now = difftime(time(0), startSimulation);
      while(now < configurazione.SO_SIM_SEC){
         sleep(1);
	 clear();
	 
	 /*show last update*/
	 printf("ultimo aggiornamento: %.2f/%d\n",difftime(time(0),startSimulation),configurazione.SO_SIM_SEC);
	 /*conta la quantita di utenti attivi*/
	 showUsers();
	 	 
	 /*mostra i nodi con i suoi semafori */
	 showNodes();
	 printf("\n");

         now = difftime(time(0), startSimulation);
      }

      /*solo por confirmar al final*/
      for(i=0;i<libroCounter;i++){
         printf("%f: %d %d %d\n",libroMastro[i].timestamp,libroMastro[i].sender,libroMastro[i].receiver, libroMastro[i].quantita);
      }
            

   }
   return 0;
}
  #+end_src
