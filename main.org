#+title: Libro Mastro
#+author: José Santos L.
* Headers
** Basic libraries
   sono librerie che non credo di aver bisogno di spiegare cosa fanno.
   #+begin_src c :tangle yes
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>/*aggiunge i boolean var*/
#include <math.h>
   #+end_src

** specific libraries
   #+begin_src c :tangle yes
#include <unistd.h> /*Header per sleep()*/
#include <pthread.h> /*per fare i thread*/

   #+end_src
** Constants
   Le costanti sono definite all'inizio come se fosse definito nella 
   compilazione come l'hanno chiesto nella documentazione del progetto. 
   Questo permette definire la grandezza delle ARRAYS di transazioni,
   che sono il libro mastro e il blocco di transazioni di ogni nodo.

  #+begin_src c :tangle yes
#define SO_BLOCK_SIZE 10
#define SO_REGISTRY_SIZE 1000
#define clear() printf("\033[H\033[J") 
  #+end_src
* structures
  Le strutture sono gruppi di variabili che rapressentano un
  oggetto della vita reale.
** ReadStruct
   questa struttura solo serve per avere un archivio di dati ordinati
   dei dati letti del file di configurazione. questi dati sono:
|---------------------------------------+------------------------------------------------------------------------------------------------------------------|
| variable                              | description                                                                                                      |
|---------------------------------------+------------------------------------------------------------------------------------------------------------------|
| SO_USERS_NUM                          | numero di processi utente                                                                                        |
| SO_NODES_NUM                          | numero di processi nodo                                                                                          |
| SO_BUDGET_INIT                        | budget iniziale di ciascun processo utente                                                                       |
| SO_REWARD                             | la percentuale di reward pagata da ogni utente per il processamento di una transazione                           |
| SO_MIN_TRANS_GEN_NSEC                 | minimo valore del tempo che trascorre fra la generazione di una transazione e la seguente da parte di un utente  |
| SO_MAX_TRANS_GEN_NSEC                 | massimo valore del tempo che trascorre fra la generazione di una transazione e la seguente da parte di un utente |
| SO_RETRY                              | numero massimo di fallimenti consecutivi nella generazione di transazioni dopo cui un processo utente termina    |
| SO_TP_SIZE                            | numero massimo di transazioni nella transaction pool dei processi nodo                                           |
| SO_BLOCK_SIZE                         | numero di transazioni contenute in un blocco                                                                     |
| SO_MIN_TRANS_PROC_NSEC,               | minimo valore del tempo simulato(nanosecondi) di processamento di un blocco da parte di un nodo                  |
| SO_MAX_TRANS_PROC_NSEC                | massimo valore del tempo simulato(nanosecondi) di processamento di un blocco da parte di un nodo                 |
| SO_REGISTRY_SIZE                      | numero massimo di blocchi nel libro mastro.                                                                      |
| SO_SIM_SESC                           | durata della simulazione                                                                                         |
| SO_NUM_FRIENDS (solo versione max 30) | numero di nodi amici dei processi nodo (solo per la versione full)                                               |
| SO_HOPS (solo versione max 30)        | numero massimo di inoltri di una transazione verso nodi amici prima che il master creai un nuovo nodo            |
|---------------------------------------+------------------------------------------------------------------------------------------------------------------|
   Anche e' vero che si poteva leggere tutte le variabili senza metterlo
   in una sola struttura. ma mi sembra molto piu ordinato mettendo tutto 
   cosi.
#+begin_src c :tangle yes

/*strutruttura della configurazione.*/
struct readStruct{
   int SO_USERS_NUM;/*numero di processi utente*/
   int SO_NODES_NUM;/*numero di processi nodo*/
   int SO_BUDGET_INIT;/*budget iniziale di ciascun processo utente*/
   int SO_REWARD;/*la percentuale di reward pagata da ogni utente per il processamento di una transazione*/
   int SO_MIN_TRANS_GEN_NSEC;/*minimo valore del tempo che trascorre fra la generazione di una transazione e la seguente da parte di un utente*/
   int SO_MAX_TRANS_GEN_NSEC;/*massimo valore del tempo che trascorre fra la generazione di una transazione e la seguente da parte di un utente*/
   int SO_RETRY;/*numero massimo di fallimenti consecutivi nella generazione di transazioni dopo cui un processo utente termina*/
   int SO_TP_SIZE;/*numero massimo di transazioni nella transaction pool dei processi nodo*/
   /*int SO_BLOCK_SIZE;/*numero di transazioni contenute in un blocco*/
   int SO_MIN_TRANS_PROC_NSEC;/*minimo valore del tempo simulato(nanosecondi) di processamento di un blocco da parte di un nodo*/
   int SO_MAX_TRANS_PROC_NSEC;/*massimo valore del tempo simulato(nanosecondi) di processamento di un blocco da parte di un nodo*/
   /*int SO_REGISTRY_SIZE;/*numero massimo di blocchi nel libro mastro*/
   int SO_SIM_SEC;/*durata della simulazione*/
   int SO_FRIENDS_NUM;/*solo per la versione full. numero di nodi amici dei processi nodo (solo per la versione full)*/
   int SO_HOPS;/*solo per la versione full. numero massimo di inoltri di una transazione verso nodi amici prima che il master creai un nuovo nodo*/ 
}configurazione;

#+end_src
   Questa struttura è gia dichiarata con la variabile _configurazione_ 
  perche solo c'è una lettura delle variabili di configurazione.

** Transazione
  Una transazione è caratterizzata dalle seguenti informazioni:
  • timestamp della transazione con risoluzione dei nanosecondi (si 
    veda funzione clock_gettime(...))
  • sender (implicito, in quanto è l’utente che ha generato la 
    transazione)
  • receiver, utente destinatario della somma
  • quantità di denaro inviata.
  • reward, denaro pagato dal sender al nodo che processa la 
    transazione.

  La transazione è inviata dal processo utente che la genera ad uno 
  dei processi nodo, scelto a caso.
  #+begin_src c :tangle yes
struct Transazione{
   time_t timestamp;
   int sender;
   int receiver;
   int quantita;
   int reward;
};

struct Transazione libroMastro[SO_REGISTRY_SIZE][SO_BLOCK_SIZE];
int libroCounter=0;

   #+end_src
* funzioni in parallelo 
  questo spazio è riservato per le funzioni del multithread

** utente
   #+begin_src c :tangle yes

void* utente(void* conf){
   int budget = configurazione.SO_BUDGET_INIT;
   int range = configurazione.SO_MAX_TRANS_GEN_NSEC - configurazione.SO_MIN_TRANS_GEN_NSEC;
   int *myid = (int *)conf;
   int mythr = pthread_self();
   int tentativi = 0;
   printf("Utente #%d creato nel thread %d\n",*myid,mythr);
   while(tentativi<configurazione.SO_RETRY){
      if(budget>2){
         /*qui va la struttura della transazione*/
      }else{
         tentativi++;
      }
      /*sceglie il tempo a caso*/
      sleep((rand() % (range + 1)) + configurazione.SO_MIN_TRANS_GEN_NSEC);
   }
}

   #+end_src
** Node
   #+begin_src c :tangle yes
void* nodo(void* conf){
   int counter=0;/*contatore della quantita di transazioni nel blocco*/
   struct Transazione blocco[SO_BLOCK_SIZE];
   struct Transazione pool[configurazione.SO_TP_SIZE];/*=malloc(configurazione.SO_TP_SIZE * (4 * sizeof(int)) * sizeof(time_t)));*/
}

   #+end_src

* lettura della configurazione
#+begin_src c :tangle yes
/*Un picollo metodo che fa un fgets(con gli stessi parametri e lo 
ritorna come un valore intero*/
int readAndInt(char *str, int n, FILE *stream){
   fgets(str,n,stream);
   printf("%d\n",atoi(str));/*manual debug*/
   return atoi(str);
}
/*funzione che cerca la maniera di leggere il config file.
/*metodo basato in codice di stackoverflow per leggere file come
una unica struttura.*/
void readconf(char fileName[]){
   /*secondo lo std c89 tutte le variabile devono 
   essere dichiarate prima del primo codice */
   struct readStruct lec;
   FILE *file= fopen(fileName, "r");

   if(!file){
      printf("non si trova il config file.\n");
      exit(EXIT_FAILURE);
   }else{
      char line[20];/*str per prendere le righe*/

      /*inserisco le variabili riga a riga alla struttura.*/
      configurazione.SO_USERS_NUM = readAndInt(line,10,file);
      configurazione.SO_NODES_NUM = readAndInt(line,10,file);
      configurazione.SO_BUDGET_INIT = readAndInt(line,10,file);
      configurazione.SO_REWARD = readAndInt(line,10,file);
      configurazione.SO_MIN_TRANS_GEN_NSEC = readAndInt(line,10,file);
      configurazione.SO_MAX_TRANS_GEN_NSEC = readAndInt(line,10,file);
      configurazione.SO_RETRY = readAndInt(line,10,file);
      configurazione.SO_TP_SIZE = readAndInt(line,10,file);
      configurazione.SO_MIN_TRANS_PROC_NSEC = readAndInt(line,10,file);
      configurazione.SO_MAX_TRANS_PROC_NSEC = readAndInt(line,10,file);
      /*configurazione.SO_REGISTRY_SIZE = readAndInt(line,10,file);*/
      configurazione.SO_SIM_SEC = readAndInt(line,10,file);
      configurazione.SO_FRIENDS_NUM = readAndInt(line,10,file);
      configurazione.SO_HOPS = readAndInt(line,10,file);
   }
   fclose(file);/*chiusura del file.*/
}

#+end_src
* scrittura di configurazione a mano
Forse per la parte di prove. possiamo cambiare la intro delle variabili.
probabilmente cancelliamo questo alla fine del progetto.
l'idea e' poter inserire le variabili a mano
#+begin_src c :tangle yes
/*scritura manuale dei valori del sistema.*/
void writeConf(){
   printf("inserendo il parametro 'mano' o 'manual' si attiva il inserimento manuale dei valori\n\n");
   printf("SO_USERS_NUM: ");
   scanf("%d",&configurazione.SO_USERS_NUM);
   printf("SO_NODES_NUM: ");
   scanf("%d",&configurazione.SO_NODES_NUM);
   printf("SO_BUDGET_INIT: ");
   scanf("%d",&configurazione.SO_BUDGET_INIT);
   printf("SO_REWARD: ");
   scanf("%d",&configurazione.SO_REWARD);
   printf("SO_MIN_TRANS_GEN_NSEC: ");
   scanf("%d",&configurazione.SO_MIN_TRANS_GEN_NSEC);
   printf("SO_MAX_TRANS_GEN_NSEC: ");
   scanf("%d",&configurazione.SO_MAX_TRANS_GEN_NSEC);
   printf("SO_RETRY: ");
   scanf("%d",&configurazione.SO_RETRY);
   printf("SO_TP_SIZE: ");
   scanf("%d",&configurazione.SO_TP_SIZE);
   printf("SO_MIN_TRANS_PROC_NSEC: ");
   scanf("%d",&configurazione.SO_MIN_TRANS_PROC_NSEC);
   printf("SO_MAX_TRANS_PROC_NSEC: ");
   scanf("%d",&configurazione.SO_MAX_TRANS_PROC_NSEC);
   printf("SO_SIM_SEC: ");
   scanf("%d",&configurazione.SO_SIM_SEC);
   printf("SO_FRIENDS_NUM: ");
   scanf("%d",&configurazione.SO_FRIENDS_NUM);
   printf("SO_HOPS: ");
   scanf("%d",&configurazione.SO_HOPS);
   clear();

}
#+end_src
* main
  #+begin_src c :tangle yes
int main(int argc,char *argv[]){
   int i;
   pthread_t tid;
   if(argc<2){
      printf("si aspettava un file con la configurazione o il commando 'manual'.\n");
      exit(EXIT_FAILURE);
   }else if(argc>2){
      printf("troppi argomenti.\n");
      exit(EXIT_FAILURE);
   }else{
      /*in caso di voler inserire i valori a mano*/
      if( strcmp(argv[1],"mano")==0 || strcmp(argv[1],"manual")==0 ){
         writeConf();
      }else{
         readconf(argv[1]);/*lettura del file*/
      }
      
      /*now that we have all the variables we can start the process
      master*/

      /*libroMastro=malloc(configurazione.SO_BLOCK_SIZE * configurazione.SO_REGISTRY_SIZE * (4 * sizeof(int)) * sizeof(time_t));*/
      /*generatore dei utenti e nodi*/
      for(i=0;i<configurazione.SO_USERS_NUM;i++){
         /*tid=i;*/
         pthread_create(&tid,NULL,utente,(void *)&i);
      }

   }
   return 0;
}
  #+end_src
